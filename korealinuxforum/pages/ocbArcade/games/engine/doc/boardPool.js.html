<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: pwge/boardPool.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: pwge/boardPool.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>define("pwge/boardPool", ["pwge/renderer", "util/ObjectPool", "pwge/util"], function(renderer, ObjectPool, util){
    var Board,
        /**
         * boardPool 모듈
         * @exports pwge/boardPool
         * @requires pwge/renderer
         * @requires pwge/util
         */
        boardPool;

    /**
     * Board 객체를 생성한다.
     * Board 객체는 util/ObjectPool로 관리되며 boardPool.allocate() 메서드로 할당해 사용한다.
     * @class
     * @param {String} name Board의 이름
     * @param {Object} options 옵션 객체
     * @example
     * var newBoard = boardPool.allocate("boardname");
     *
     * @example
     * var newBoard = boardPool.allocate("boardname", { x : 50, y : 100 }); //Board의 기준점. Board내의 모든 Entity들의 위치값에 영향을 준다.
     */
    Board = function(name, options){
        this.name = name;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.dirty = true;
        this.entities = [];
        this.enabled = false;
        this.paused = true;
        this.startedTime = 0;
        this.pausedTime = 0;
        this.past = 0;
        this._timeline = [];

        util.extend(this, options);
    };
    /**
     * Board에 Entity를 추가한다.
     * @param {Entity} entity Entity 객체
     * @return {Board}
     */
    Board.prototype.addEntity = function(entity) {
        if (!this.findEntity(entity)) {
            this.entities.push(entity);
            entity.owner = this;
            this.dirty = true;
        }
        return this;
    };
    /**
     * Entity를 찾는다.
     * @param  {Entity | String | Function} entity 또는 entity.id 또는 비교함수
     * @return {Entity | Array | null}
     *
     * @example
     * board.findEntity(entity)
     * board.findEntity("id")
     * board.findEntity(function(entity) {
     *     return entity.type === "test"; //또는 this.type === "test"
     * });
     */
    Board.prototype.findEntity = function(entity) {
        var id, fn, ret, i, len;

        switch(typeof entity) {
            case "string":
                id = entity;
                break;
            case "function":
                fn = entity;
                break;
            case "object":
                id = entity.id;
        }

        if (id) {
            for (i = 0, len = this.entities.length; i &lt; len; i++) {
                if (this.entities[i] &amp;&amp; this.entities[i].id === id) {
                    return this.entities[i];
                }
            }
            return null;
        } else if (fn) {
            ret = [];
            for (i = 0, len = this.entities.length; i &lt; len; i++) {
                if (this.entities[i] &amp;&amp; fn.call(this.entities[i], this.entities[i])) {
                    ret.push(this.entities[i]);
                }
            }
            if (ret.length === 1) {
                return ret[0];
            }
            if (ret.length) {
                return ret;
            }
            return null;
        }
    };

    /**
     * 이벤트 위치에 해당하는 Entity를 찾는다.
     * @param {Number} x
     * @param {Number} y
     * @return {Entity | null}
     */
    Board.prototype.detect = function(x, y, width, height) {
        width = width || 1;
        height = height || 1;

        var o = {
            x : x,
            y : y,
            width : width,
            height : height,
            anchorX : 0,
            anchorY : 0
        }, overlap = false;

        for (var i = 0, len = this.entities.length; i &lt; len; i++) {
            if (this.entities[i] &amp;&amp; this.entities[i].detectable &amp;&amp; (overlap = util.overlap(o, this.entities[i]))) {
                return this.entities[i];
            }
        }
        return null;
    };
    /**
     * Entity를 Board에서 제거한다.
     * @param  {Entity | String} entity 제거할 Entity 혹은 Entity.id
     * @return {Board}
     */
    Board.prototype.removeEntity = function(entity) {
        entity = this.findEntity(entity);
        if (entity) {
            for (var i = 0, len = this.entities.length; i &lt; len; i++) {
                if (this.entities[i] &amp;&amp; this.entities[i].id === entity.id) {
                    this.entities[i] = null; //_flush에서 실제로 제거
                    this.dirty = true;
                }
            }
        }
        return this;
    };
    /**
     * Board가 렌더링되도록 enable 시킨다.
     * 동시에 다시재생될 수 있도록 resume된다.
     * @return {Board}
     */
    Board.prototype.enable = function() {
        if (!this.enabled) {
            this.dirty = true;
            this.resume();
            this.enabled = true;
        }
        return this;
    };
    /**
     * Board가 렌더링되지 않도록 disable 시킨다.
     * 동시에 재생이 진행되지 않도록 pause된다.
     * @return {Board}
     */
    Board.prototype.disable = function() {
        if (this.enabled) {
            this.dirty = true;
            this.pause();
            this.enabled = false;
        }
        return this;
    };
    /**
     * 재생을 중지시키기 위해 pause시킨다.
     * step메서드내에서 타임라인이 진행되지 않도록 한다.
     * @return {Board}
     */
    Board.prototype.pause = function() {
        if (!this.paused) {
            this.dirty = true;
            this.paused = true;
            this.pausedTime = this.past;
        }
        return this;
    };
    /**
     * 다시재생시키기 위해 resume시킨다.
     * step메서드내에서 타임라인이 다시 진행되도록 한다.
     * @return {Board}
     */
    Board.prototype.resume = function() {
        if (this.paused) {
            this.dirty = true;
            this.paused = false;
            this.startedTime = renderer.now() - this.past;
        }
        return this;
    };
    /**
     * Board의 현재 타임라인 진행 시간을 리턴한다.
     * @return {Number} 타임라인 진행 시간
     */
    Board.prototype.now = function() {
        return this.past;
    };
    // Board.prototype.restart = function() {
    //     this.startedTime = this.past;
    //     this.paused = true;
    //     this.pausedTime = this.past;
    //     this.past = 0;
    //     this._done = [];
    //     this._done.length = this._timeline.length;
    //     // console.log(this._timeline, this._done);
    //     return this;
    // };

    /**
     * 렌더러에 의해 호출되어, Board의 타임라인 진행에 따라 포함된 Entitiy들의 위치값을 계산하는 step함수를 실행시킨다.
     * @param  {String} dt 렌더러의 타임라인 진행시간
     */
    Board.prototype.step = function(dt) {
        var i, len;
        if (this.paused) {
            dt = this.past;
        } else {
            dt = dt - this.startedTime;
        }

        this.past = dt;

        this._doTask(dt);
        for (i = 0, len = this.entities.length; i &lt; len; i++) {
            if (this.entities[i] &amp;&amp; renderer.isRendering &amp;&amp; this.enabled &amp;&amp; this.entities[i].enabled) {
                this.entities[i].step(dt);
            }
        }

        // console.log(dt)
    };
    /**
     * 렌더러에 의해 호출되어, Board의 타임라인 진행에 따라 포함된 Entitiy들의 페인팅을 담당하는 step함수를 실행시킨다.
     * @param  {String} dt 렌더러의 타임라인 진행시간
     */
    Board.prototype.draw = function(dt) {
        var i, len;
        if (this.paused) {
            dt = this.past;
        } else {
            dt = dt - this.startedTime;
        }

        this.past = dt;

        for (i = 0, len = this.entities.length; i &lt; len; i++) {
            if (this.entities[i] &amp;&amp; renderer.isRendering &amp;&amp; this.enabled &amp;&amp; this.entities[i].enabled) {
                this.entities[i].draw(dt);
                this.entities[i]._checkDirty();
            }
        }

        // console.log(dt)
    };
    Board.prototype._flush = function() {
        var i, len;
        //delete removed entities
        i = this.entities.length;
        while (i--) {
            if (!this.entities[i]) {
                this.entities.splice(i, 1);
            }
        }

        //sort
        this.orderedEntities = util.sortByZ(this.entities);

        for (i = 0, len = this.orderedEntities.length; i &lt; len; i++) {
            if (renderer.isRendering &amp;&amp; this.enabled &amp;&amp; this.orderedEntities[i].enabled) {
                this.orderedEntities[i]._flush();
            }
        }
    };
    /**
     * Board의 타임라인 진행에 따라 실행할 콜백을 등록한다.
     * @param  {Array} timeline 타임라인정보 배열
     * @return {Board}
     */
    Board.prototype.timeline = function(timeline) {
        this._timeline = timeline;
        this._done = [];
        this._done.length = this._timeline.length;
        return this;
    };
    /**
     * timeline메서드로 등록된 타임라인정보를 가지고, step 메서드에서 현재 진행시간에 맞는 콜백을 실행시킨다.
     * @param   {Number} dt 타임라인진행 시간
     * @return  {Board}
     * @private
     */
    Board.prototype._doTask = function(dt) {
        var target = -1;
        for (var i = 0; i &lt; this._timeline.length; i++) {
            if (this._timeline[i][0] &lt; dt) {
                target = i;
            }
        }

        if (target > -1) {
            task = this._timeline[target];
            if (!this._done[target]) {
                this._done[target] = true;
                task[1].call(this, task[0], dt);
            }
        }

    };

    /**
     * board를 삭제한다.
     * 삭제된 후에는 다시 객체 풀에 반환된다.
     */
    Board.prototype.destroy = function() {
        this.entities.length = 0;
        this._timeline.length = 0;
        boardPool.free(this);
    };

    boardPool = new ObjectPool(Board, 16);

    return boardPool;
});</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="boardManager.html">pwge/boardManager</a></li><li><a href="boardPool.html">pwge/boardPool</a></li><li><a href="canvas.html">pwge/canvas</a></li><li><a href="config.html">pwge/config</a></li><li><a href="entityPool.html">pwge/entityPool</a></li><li><a href="input.html">pwge/input</a></li><li><a href="loader.html">pwge/loader</a></li><li><a href="renderer.html">pwge/renderer</a></li><li><a href="sound.html">pwge/sound</a></li><li><a href="spriteManager.html">pwge/spriteManager</a></li><li><a href="util.html">pwge/util</a></li><li><a href="easing.html">util/easing</a></li><li><a href="ObjectPool.html">util/ObjectPool</a></li><li><a href="PubSub.html">util/PubSub</a></li></ul><h3>Classes</h3><ul><li><a href="boardPool-Board.html">Board</a></li><li><a href="entityPool-Entity.html">Entity</a></li><li><a href="spriteManager-Sprite.html">Sprite</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha2</a> on Thu Feb 06 2014 11:24:18 GMT+0900 (KST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
