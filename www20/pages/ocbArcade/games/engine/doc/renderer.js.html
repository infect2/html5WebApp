<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: pwge/renderer.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: pwge/renderer.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>define("pwge/renderer/transition", ["pwge/canvas", "util/easing"], function(canvas, easing){
    return {
        fade : function(past, o){
            var opacity = easing[o.easing](past, 0, 1, o.duration);
            canvas.ctx.save();
            canvas.ctx.drawImage(o.from, 0, 0, canvas.width, canvas.height);
            canvas.ctx.globalAlpha = opacity;
            canvas.ctx.drawImage(o.to, 0, 0, canvas.width, canvas.height);
            canvas.ctx.restore();
        },
        zoomIn : function(past, o){
            var zoom = easing[o.easing](past, 0, 1, o.duration);
            canvas.ctx.save();
            canvas.ctx.translate(-canvas.width / 2 * zoom + canvas.width / 2, -canvas.height / 2 * zoom + canvas.height / 2);
            canvas.ctx.scale(zoom, zoom);
            canvas.ctx.drawImage(o.to, 0, 0, canvas.width, canvas.height);
            canvas.ctx.restore();
        },
        zoomOut : function(past, o){
            var zoom = 4 - easing[o.easing](past, 0, 3, o.duration);
            canvas.ctx.save();
            canvas.ctx.translate(-canvas.width / 2 * zoom + canvas.width / 2, -canvas.height / 2 * zoom + canvas.height / 2);
            canvas.ctx.scale(zoom, zoom);
            canvas.ctx.drawImage(o.to, 0, 0, canvas.width, canvas.height);
            canvas.ctx.restore();
        },
        slideInRight : function(past, o) {
            var left = Math.round(easing[o.easing](past, 0, canvas.width, o.duration));
            canvas.ctx.save();
            canvas.ctx.translate(-left, 0);
            canvas.ctx.drawImage(o.from, 0, 0, canvas.width, canvas.height);
            canvas.ctx.translate(canvas.width, 0);
            canvas.ctx.drawImage(o.to, 0, 0, canvas.width, canvas.height);
            canvas.ctx.restore();
        },
        slideInLeft : function(past, o) {
            var left = Math.round(easing[o.easing](past, 0, canvas.width, o.duration));
            canvas.ctx.save();
            canvas.ctx.translate(left, 0);
            canvas.ctx.drawImage(o.from, 0, 0, canvas.width, canvas.height);
            canvas.ctx.translate(-canvas.width, 0);
            canvas.ctx.drawImage(o.to, 0, 0, canvas.width, canvas.height);
            canvas.ctx.restore();
        },
        slideInBottom : function(past, o) {
            var top = Math.round(easing[o.easing](past, 0, canvas.height, o.duration));
            canvas.ctx.save();
            canvas.ctx.translate(0, -top);
            canvas.ctx.drawImage(o.from, 0, 0, canvas.width, canvas.height);
            canvas.ctx.translate(0, canvas.height);
            canvas.ctx.drawImage(o.to, 0, 0, canvas.width, canvas.height);
            canvas.ctx.restore();
        },
        slideInTop : function(past, o) {
            var top = Math.round(easing[o.easing](past, 0, canvas.height, o.duration));
            canvas.ctx.save();
            canvas.ctx.translate(0, top);
            canvas.ctx.drawImage(o.from, 0, 0, canvas.width, canvas.height);
            canvas.ctx.translate(0, -canvas.height);
            canvas.ctx.drawImage(o.to, 0, 0, canvas.width, canvas.height);
            canvas.ctx.restore();
        },
        moveInRight : function(past, o) {
            var left = Math.round(easing[o.easing](past, 0, canvas.width, o.duration));
            canvas.ctx.save();
            canvas.ctx.drawImage(o.from, 0, 0, canvas.width, canvas.height);
            canvas.ctx.translate(canvas.width - left, 0);
            canvas.ctx.drawImage(o.to, 0, 0, canvas.width, canvas.height);
            canvas.ctx.restore();
        },
        moveInLeft : function(past, o) {
            var left = Math.round(easing[o.easing](past, 0, canvas.width, o.duration));
            canvas.ctx.save();
            canvas.ctx.drawImage(o.from, 0, 0, canvas.width, canvas.height);
            canvas.ctx.translate(-canvas.width + left, 0);
            canvas.ctx.drawImage(o.to, 0, 0, canvas.width, canvas.height);
            canvas.ctx.restore();
        },
        moveInBottom : function(past, o) {
            var top = Math.round(easing[o.easing](past, 0, canvas.height, o.duration));
            canvas.ctx.save();
            canvas.ctx.drawImage(o.from, 0, 0, canvas.width, canvas.height);
            canvas.ctx.translate(0, canvas.height - top);
            canvas.ctx.drawImage(o.to, 0, 0, canvas.width, canvas.height);
            canvas.ctx.restore();
        },
        moveInTop : function(past, o) {
            var top = Math.round(easing[o.easing](past, 0, canvas.height, o.duration));
            canvas.ctx.save();
            canvas.ctx.drawImage(o.from, 0, 0, canvas.width, canvas.height);
            canvas.ctx.translate(0, top - canvas.height);
            canvas.ctx.drawImage(o.to, 0, 0, canvas.width, canvas.height);
            canvas.ctx.restore();
        }
    };
});

define("pwge/renderer", ["pwge/config", "pwge/canvas", "util/PubSub", "pwge/util", "pwge/renderer/transition"], function(config, canvas, PubSub, util, transition){
    var raf,
        now = 0,
        loop = function() {
            raf = requestAnimationFrame(loop);
            now = +new Date() - startedTime + pausedTime;
            renderer.render(now);
        },
        scene = {},
        currentScene,
        isRendering = false,
        startedTime = 0,
        pausedTime = 0,
        /**
         * renderer 모듈
         * @exports pwge/renderer
         * @requires pwge/canvas
         * @requires util/PubSub
         */
        renderer = new PubSub();

    /**
     * 현재 씬을 강제 렌더링한다.
     * 렌더링중에 반복해서 호출된다.
     * @return {renderer}
     */
    renderer.render = function(time){
        if (isRendering) {
            renderer.trigger("step", time);
            renderer.trigger("draw", time);
        }
        return this;
    };
    /**
     * 렌더링을 시작한다.
     * pause한 경우 재시작한다.
     * @return {renderer}
     */
    renderer.start = function(){
        startedTime = +new Date();
        isRendering = true;
        loop();

        return this;
    };

    /**
     * 렌더링을 재시작한다.
     * @return {renderer}
     * @see renderer.resume
     */
    renderer.resume = renderer.start;

    /**
     * 렌더링을 일시정지한다.
     * 이후 start시 resume된다.
     * @return {renderer}
     */
    renderer.pause = function(){
        pausedTime = now;
        cancelAnimationFrame(raf);
        isRendering = false;
        return this;
    };

    /**
     * 렌더링을 중단한다.
     * 이후 start시 처음부터 다시 시작된다.
     * @return {renderer}
     */
    renderer.stop = function(){
        pausedTime = 0;
        cancelAnimationFrame(raf);
        isRendering = false;
        return this;
    };

    /**
     * 렌더러의 현재 진행 시간을 가져온다.
     * @return {Number} 진행시간 (ms)
     */
    renderer.now = function(){
        return now;
    };

    renderer.isRendering = function() {
        return isRendering;
    };

    /**
     * scene을 만든다.
     * @param  {String} sceneName scene의 이름
     * @param  {String} boardName scene에 포함시킬 board의 이름. 또는 이름의 배열
     * @return {renderer}
     */
    renderer.makeScene = function(sceneName, boardName){
        scene[sceneName] = (!Array.isArray(boardName)) ? [boardName] : boardName;
        return this;
    };

    /**
     * scene을 전환한다. 전환된 scene에 포함된 board들만 enable되고, 나머지는 disable된다.
     * @param  {String} sceneName 전환할 scene의 이름
     * @param  {String | Object} transition 전환효과명 또는 전환효과옵션객체
     * @return {renderer}
     * @example
     * renderer.switchScene("targetScene");
     * @example
     * renderer.switchScene("targetScene", "zoomIn");
     * @example
     * renderer.switchScene("targetScene", {
     *     type : "zoomOut",
     *     easing : "easeInOutQuad",
     *     duration : 2000
     * });
     */
    renderer.switchScene = function(sceneName, transition){
        var targetBoards = scene[sceneName];
        if (targetBoards) {
            currentScene = sceneName;
            if (typeof transition === "undefined") { //normal
                this.trigger("switchScene", targetBoards);
            } else { //transision
                if (typeof transition === "string") {
                    transition = {
                        type : transition
                    };
                }

                this.trigger("switchScene", targetBoards, transition);
            }
        }

        return this;
    };

    /**
     * 현재 재생중인 scene의 이름을 구한다.
     * @return {String}
     */
    renderer.getCurrentScene = function() {
        return currentScene;
    };

    /**
     * 현재 재생중인 화면의 스냅샷을 구한다.
     * @return {HTMLCanvasElement} 캔버스 엘리먼트 (오프스크린이므로 화면 재생에 영향을 주지 않는다.)
     */
    renderer.snapShot = function() {
        var offscreenCanvas = canvas.offscreen();
        canvas.ctx = offscreenCanvas.getContext("2d"); //temporarily switch context
        canvas.ctx.drawImage(canvas.element, 0, 0, canvas.width, canvas.height); //이전 화면을 복사
        this.render(now);
        canvas.ctx = canvas.element.getContext("2d"); //restore context
        // document.body.appendChild(offscreenCanvas);
        return offscreenCanvas;
    };

    renderer._transition = function(o) {
        this.pause();
        o = util.extend({
            duration : 500,
            easing : "linear",
            start : +new Date()
        }, o);

        var loop = (function(){
                return function(){
                    canvas.clear();
                    var past = (+new Date() - o.start),
                        opacity;
                    if (past &lt;= o.duration) {
                        transition[o.type](past, o);
                        if (config.planetWebview &amp;&amp; canvas.ctx.canvas === canvas.element &amp;&amp; canvas.ctx.flush) {
                            canvas.ctx.flush();
                        }
                        requestAnimationFrame(loop);
                    } else {
                        canvas.ctx.drawImage(o.to, 0, 0, canvas.width, canvas.height);
                        if (typeof o.callback === "function") {
                            o.callback();
                        }
                        this.resume();
                    }
                };
            }()).bind(renderer);

        loop();
    };

    return renderer;
});</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="boardManager.html">pwge/boardManager</a></li><li><a href="boardPool.html">pwge/boardPool</a></li><li><a href="canvas.html">pwge/canvas</a></li><li><a href="config.html">pwge/config</a></li><li><a href="entityPool.html">pwge/entityPool</a></li><li><a href="input.html">pwge/input</a></li><li><a href="loader.html">pwge/loader</a></li><li><a href="renderer.html">pwge/renderer</a></li><li><a href="sound.html">pwge/sound</a></li><li><a href="spriteManager.html">pwge/spriteManager</a></li><li><a href="util.html">pwge/util</a></li><li><a href="easing.html">util/easing</a></li><li><a href="ObjectPool.html">util/ObjectPool</a></li><li><a href="PubSub.html">util/PubSub</a></li></ul><h3>Classes</h3><ul><li><a href="boardPool-Board.html">Board</a></li><li><a href="entityPool-Entity.html">Entity</a></li><li><a href="spriteManager-Sprite.html">Sprite</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha2</a> on Thu Feb 06 2014 11:24:18 GMT+0900 (KST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
